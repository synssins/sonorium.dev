"""\nSonorium Theme Cycle Manager\n\nBackground task that monitors playing sessions and automatically\ncycles themes based on their cycle configuration.\n"""\n\nfrom __future__ import annotations\n\nimport asyncio\nimport random\nfrom datetime import datetime, timedelta\nfrom typing import Optional, TYPE_CHECKING\n\nfrom sonorium.obs import logger\nfrom sonorium.core.state import Session, CycleConfig\n\nif TYPE_CHECKING:\n    from sonorium.core.session_manager import SessionManager\n    from sonorium.theme import ThemeDefinition\n    from fmtr.tools.iterator_tools import IndexList\n\n\nclass CycleManager:\n    \"\"\"\n    Manages automatic theme cycling for sessions.\n    \n    Runs a background task that checks playing sessions and\n    triggers theme changes based on their cycle configuration.\n    \"\"\"\n    \n    def __init__(\n        self,\n        session_manager: SessionManager = None,\n        themes: IndexList[ThemeDefinition] = None,\n        check_interval: float = 10.0,  # seconds between checks\n    ):\n        \"\"\"\n        Initialize CycleManager.\n        \n        Args:\n            session_manager: SessionManager for accessing sessions\n            themes: List of available themes\n            check_interval: How often to check for needed cycles (seconds)\n        \"\"\"\n        self.session_manager = session_manager\n        self.themes = themes\n        self.check_interval = check_interval\n        \n        self._task: Optional[asyncio.Task] = None\n        self._running = False\n        \n        # Track cycle state per session (session_id -> runtime state)\n        self._cycle_state: dict[str, dict] = {}\n    \n    def set_session_manager(self, session_manager: SessionManager):\n        \"\"\"Set the session manager (for deferred initialization).\"\"\"\n        self.session_manager = session_manager\n    \n    def set_themes(self, themes: IndexList[ThemeDefinition]):\n        \"\"\"Set available themes.\"\"\"\n        self.themes = themes\n    \n    async def start(self):\n        \"\"\"Start the background cycle task.\"\"\"\n        if self._running:\n            return\n        \n        self._running = True\n        self._task = asyncio.create_task(self._cycle_loop())\n        logger.info(\"CycleManager: Started background cycle task\")\n    \n    async def stop(self):\n        \"\"\"Stop the background cycle task.\"\"\"\n        self._running = False\n        if self._task:\n            self._task.cancel()\n            try:\n                await self._task\n            except asyncio.CancelledError:\n                pass\n            self._task = None\n        logger.info(\"CycleManager: Stopped background cycle task\")\n    \n    async def _cycle_loop(self):\n        \"\"\"Main cycle loop - runs until stopped.\"\"\"\n        while self._running:\n            try:\n                await self._check_cycles()\n            except Exception as e:\n                logger.error(f\"CycleManager: Error in cycle loop: {e}\")\n            \n            await asyncio.sleep(self.check_interval)\n    \n    async def _check_cycles(self):\n        \"\"\"Check all playing sessions for needed theme cycles.\"\"\"\n        if not self.session_manager:\n            return\n        \n        now = datetime.utcnow()\n        \n        for session in self.session_manager.list():\n            if not session.is_playing:\n                # Clean up state for non-playing sessions\n                self._cycle_state.pop(session.id, None)\n                continue\n            \n            if not session.cycle_config or not session.cycle_config.enabled:\n                continue\n            \n            # Check if it's time to cycle\n            if self._should_cycle(session, now):\n                await self._cycle_theme(session)\n    \n    def _should_cycle(self, session: Session, now: datetime) -> bool:\n        \"\"\"\n        Determine if a session should cycle to the next theme.\n        \n        Returns True if enough time has passed since last change.\n        \"\"\"\n        state = self._get_cycle_state(session)\n        \n        if state['last_change'] is None:\n            # First time - initialize and don't cycle yet\n            state['last_change'] = now\n            return False\n        \n        interval = timedelta(minutes=session.cycle_config.interval_minutes)\n        next_change = state['last_change'] + interval\n        \n        return now >= next_change\n    \n    def _get_cycle_state(self, session: Session) -> dict:\n        \"\"\"Get or create runtime cycle state for a session.\"\"\"\n        if session.id not in self._cycle_state:\n            self._cycle_state[session.id] = {\n                'last_change': None,\n                'current_index': 0,\n                'shuffled_themes': None,\n            }\n        return self._cycle_state[session.id]\n    \n    def _get_theme_list(self, session: Session) -> list[str]:\n        \"\"\"\n        Get the list of theme IDs to cycle through.\n        \n        If cycle_config.theme_ids is set, use that list.\n        Otherwise, use all available themes.\n        \"\"\"\n        if session.cycle_config.theme_ids:\n            # Use configured theme list\n            return session.cycle_config.theme_ids\n        \n        # Use all available themes\n        if self.themes:\n            return [t.id for t in self.themes]\n        \n        return []\n    \n    def _get_next_theme(self, session: Session) -> Optional[str]:\n        \"\"\"\n        Get the next theme ID for a session.\n        \n        Handles both sequential and random cycling.\n        \"\"\"\n        state = self._get_cycle_state(session)\n        theme_list = self._get_theme_list(session)\n        \n        if not theme_list:\n            return None\n        \n        # Filter out current theme to avoid repeating\n        available = [t for t in theme_list if t != session.theme_id]\n        if not available:\n            # Only one theme - nothing to cycle to\n            return None\n        \n        if session.cycle_config.randomize:\n            # Random selection\n            return random.choice(available)\n        else:\n            # Sequential - move to next index\n            current_index = state.get('current_index', 0)\n            \n            # Find current theme in list\n            try:\n                if session.theme_id in theme_list:\n                    current_pos = theme_list.index(session.theme_id)\n                    next_pos = (current_pos + 1) % len(theme_list)\n                else:\n                    next_pos = current_index\n            except ValueError:\n                next_pos = 0\n            \n            state['current_index'] = next_pos\n            return theme_list[next_pos]\n    \n    async def _cycle_theme(self, session: Session):\n        \"\"\"\n        Cycle a session to its next theme.\n        \n        Uses SessionManager.update() to trigger crossfade.\n        \"\"\"\n        next_theme_id = self._get_next_theme(session)\n        \n        if not next_theme_id:\n            logger.debug(f\"CycleManager: No next theme for session {session.id}\")\n            return\n        \n        if next_theme_id == session.theme_id:\n            logger.debug(f\"CycleManager: Same theme, skipping cycle for {session.id}\")\n            return\n        \n        # Get theme name for logging\n        theme_name = next_theme_id\n        if self.themes:\n            theme = self.themes.id.get(next_theme_id)\n            if theme:\n                theme_name = theme.name\n        \n        logger.info(f\"CycleManager: Cycling session '{session.name}' to theme '{theme_name}'\")\n        \n        # Update session - this triggers crossfade via SessionManager\n        self.session_manager.update(session.id, theme_id=next_theme_id)\n        \n        # Update cycle state\n        state = self._get_cycle_state(session)\n        state['last_change'] = datetime.utcnow()\n    \n    def reset_cycle(self, session_id: str):\n        \"\"\"\n        Reset the cycle timer for a session.\n        \n        Call this when manually changing themes to restart the interval.\n        \"\"\"\n        if session_id in self._cycle_state:\n            self._cycle_state[session_id]['last_change'] = datetime.utcnow()\n        else:\n            self._cycle_state[session_id] = {\n                'last_change': datetime.utcnow(),\n                'current_index': 0,\n                'shuffled_themes': None,\n            }\n    \n    def get_cycle_status(self, session_id: str) -> Optional[dict]:\n        \"\"\"\n        Get the current cycle status for a session.\n        \n        Returns dict with:\n        - next_change: ISO timestamp of next scheduled change\n        - seconds_until_change: Seconds until next change\n        - themes_in_rotation: Number of themes being cycled\n        \"\"\"\n        session = self.session_manager.get(session_id) if self.session_manager else None\n        if not session or not session.cycle_config or not session.cycle_config.enabled:\n            return None\n        \n        state = self._cycle_state.get(session_id)\n        if not state or not state.get('last_change'):\n            return {\n                'next_change': None,\n                'seconds_until_change': None,\n                'themes_in_rotation': len(self._get_theme_list(session)),\n            }\n        \n        interval = timedelta(minutes=session.cycle_config.interval_minutes)\n        next_change = state['last_change'] + interval\n        now = datetime.utcnow()\n        seconds_until = max(0, (next_change - now).total_seconds())\n        \n        return {\n            'next_change': next_change.isoformat(),\n            'seconds_until_change': int(seconds_until),\n            'themes_in_rotation': len(self._get_theme_list(session)),\n        }