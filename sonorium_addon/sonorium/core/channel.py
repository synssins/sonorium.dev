"""\nSonorium Channel System\n\nChannels are persistent audio streams that speakers connect to.\nEach channel can play one theme at a time, with smooth crossfading\nwhen switching between themes.\n\nThis allows speakers to stay connected while themes change seamlessly.\n"""\n\nfrom __future__ import annotations\n\nimport threading\nimport time\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Optional, TYPE_CHECKING, Generator\n\nimport numpy as np\n\nfrom sonorium.obs import logger\nfrom sonorium.recording import SAMPLE_RATE, CROSSFADE_SAMPLES\nfrom fmtr.tools import av\n\nif TYPE_CHECKING:\n    from sonorium.theme import ThemeDefinition, ThemeStream\n\n\n# Crossfade duration for theme transitions (in seconds)\nTHEME_CROSSFADE_DURATION = 3.0\nTHEME_CROSSFADE_SAMPLES = int(THEME_CROSSFADE_DURATION * SAMPLE_RATE)\n\n# Chunk size for silence generation\nCHUNK_SIZE = 1024\n\n# Default output gain\nDEFAULT_OUTPUT_GAIN = 6.0\n\n\nclass ChannelState(str, Enum):\n    \"\"\"Current state of a channel.\"\"\"\n    IDLE = \"idle\"              # No theme assigned, outputting silence\n    PLAYING = \"playing\"        # Playing a theme\n\n\n@dataclass\nclass Channel:\n    \"\"\"\n    A persistent audio stream channel.\n    \n    Speakers connect to channels, not themes. When a theme changes,\n    each connected client handles crossfading independently.\n    \n    The Channel just tracks WHAT theme is playing - each client\n    gets its own independent audio generator.\n    \"\"\"\n    \n    id: int\n    name: str = \"\"\n    \n    # Current theme reference\n    _current_theme: Optional[ThemeDefinition] = field(default=None, repr=False)\n    \n    # Theme version - increments when theme changes, clients use this to detect changes\n    _theme_version: int = 0\n    \n    # State tracking\n    state: ChannelState = ChannelState.IDLE\n    \n    # Active client count (for resource management)\n    _client_count: int = 0\n    \n    # Lock for thread-safe theme changes\n    _lock: threading.Lock = field(default_factory=threading.Lock, repr=False)\n    \n    def __post_init__(self):\n        if not self.name:\n            self.name = f\"Channel {self.id}\"\n    \n    @property\n    def current_theme(self) -> Optional[ThemeDefinition]:\n        \"\"\"Get the current theme.\"\"\"\n        return self._current_theme\n    \n    @property\n    def current_theme_id(self) -> Optional[str]:\n        \"\"\"Get the current theme ID.\"\"\"\n        return self._current_theme.id if self._current_theme else None\n    \n    @property\n    def current_theme_name(self) -> Optional[str]:\n        \"\"\"Get the current theme name.\"\"\"\n        return self._current_theme.name if self._current_theme else None\n    \n    @property\n    def theme_version(self) -> int:\n        \"\"\"Get current theme version (for change detection).\"\"\"\n        return self._theme_version\n    \n    @property\n    def is_active(self) -> bool:\n        \"\"\"Check if channel has connected clients.\"\"\"\n        return self._client_count > 0\n    \n    @property \n    def stream_path(self) -> str:\n        \"\"\"Get the stream URL path for this channel.\"\"\"\n        return f\"/stream/channel{self.id}\"\n    \n    def set_theme(self, theme: ThemeDefinition) -> None:\n        \"\"\"\n        Set or change the theme for this channel.\n        \n        Connected clients will detect the change via theme_version\n        and handle crossfading independently.\n        \"\"\"\n        with self._lock:\n            if theme == self._current_theme:\n                logger.info(f\"Channel {self.id}: Theme '{theme.name}' already active, no change needed\")\n                return\n            \n            old_theme = self._current_theme.name if self._current_theme else \"none\"\n            logger.info(f\"Channel {self.id}: Changing theme from '{old_theme}' to '{theme.name}'\")\n            \n            self._current_theme = theme\n            self._theme_version += 1\n            self.state = ChannelState.PLAYING\n    \n    def stop(self) -> None:\n        \"\"\"Stop the channel and return to idle.\"\"\"\n        with self._lock:\n            logger.info(f\"Channel {self.id}: Stopping playback\")\n            self._current_theme = None\n            self._theme_version += 1\n            self.state = ChannelState.IDLE\n    \n    def client_connected(self) -> None:\n        \"\"\"Track a new client connection.\"\"\"\n        self._client_count += 1\n        logger.info(f\"Channel {self.id}: Client connected ({self._client_count} total)\")\n    \n    def client_disconnected(self) -> None:\n        \"\"\"Track a client disconnection.\"\"\"\n        self._client_count = max(0, self._client_count - 1)\n        logger.info(f\"Channel {self.id}: Client disconnected ({self._client_count} remaining)\")\n    \n    def get_stream(self):\n        \"\"\"\n        Get an MP3 stream iterator for this channel.\n        \n        Each call creates a NEW independent stream - multiple clients\n        can connect without sharing generators.\n        \"\"\"\n        return ChannelStream(self)\n    \n    def to_dict(self) -> dict:\n        \"\"\"Serialize channel state for API.\"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"state\": self.state.value,\n            \"current_theme\": self.current_theme_id,\n            \"current_theme_name\": self.current_theme_name,\n            \"client_count\": self._client_count,\n            \"stream_path\": self.stream_path,\n        }\n\n\nclass ChannelStream:\n    \"\"\"\n    MP3 streaming wrapper for a Channel.\n    \n    Each ChannelStream has its OWN independent audio generator.\n    When the channel's theme changes, this stream handles crossfading\n    from the old theme to the new one independently.\n    \"\"\"\n    \n    def __init__(self, channel: Channel):\n        self.channel = channel\n        self.channel.client_connected()\n        \n        # Pre-generate crossfade curves (equal-power)\n        self._fade_out = np.cos(np.linspace(0, np.pi/2, THEME_CROSSFADE_SAMPLES)).astype(np.float32)\n        self._fade_in = np.sin(np.linspace(0, np.pi/2, THEME_CROSSFADE_SAMPLES)).astype(np.float32)\n        \n        # Silence chunk for idle state\n        self._silence = np.zeros((1, CHUNK_SIZE), dtype=np.int16)\n    \n    def __iter__(self):\n        output = av.open(file='.mp3', mode=\"w\")\n        bitrate = 128_000\n        out_stream = output.add_stream(codec_name='mp3', rate=SAMPLE_RATE, bit_rate=bitrate)\n\n        start_time = time.time()\n        audio_time = 0.0\n        \n        # Track which theme version we're playing\n        current_version = -1\n        current_chunks = None\n        \n        # For crossfading\n        old_chunks = None\n        crossfade_position = 0\n        is_crossfading = False\n\n        try:\n            while True:\n                # Check if theme has changed\n                channel_version = self.channel.theme_version\n                if channel_version != current_version:\n                    # Theme changed!\n                    if current_chunks is not None and self.channel.current_theme is not None:\n                        # We have an old stream - start crossfading\n                        old_chunks = current_chunks\n                        crossfade_position = 0\n                        is_crossfading = True\n                        logger.info(f\"Channel {self.channel.id} client: Starting crossfade to new theme\")\n                    \n                    # Get new theme stream\n                    current_version = channel_version\n                    if self.channel.current_theme:\n                        stream = self.channel.current_theme.get_stream()\n                        current_chunks = stream.iter_chunks()\n                    else:\n                        current_chunks = None\n                \n                # Generate audio chunk\n                if current_chunks is None:\n                    # No theme - output silence\n                    data = self._silence\n                elif is_crossfading and old_chunks is not None:\n                    # Crossfading between old and new theme\n                    try:\n                        old_chunk = next(old_chunks)\n                        new_chunk = next(current_chunks)\n                        data = self._apply_crossfade(old_chunk, new_chunk, crossfade_position)\n                        crossfade_position += data.shape[1]\n                        \n                        if crossfade_position >= THEME_CROSSFADE_SAMPLES:\n                            # Crossfade complete\n                            is_crossfading = False\n                            old_chunks = None\n                            logger.info(f\"Channel {self.channel.id} client: Crossfade complete\")\n                    except StopIteration:\n                        # Old stream ended - just use new\n                        is_crossfading = False\n                        old_chunks = None\n                        data = next(current_chunks) if current_chunks else self._silence\n                else:\n                    # Normal playback\n                    try:\n                        data = next(current_chunks)\n                    except StopIteration:\n                        data = self._silence\n                \n                # Encode to MP3\n                frame = av.AudioFrame.from_ndarray(data, format='s16', layout='mono')\n                frame.rate = SAMPLE_RATE\n\n                frame_duration = frame.samples / frame.rate\n                audio_time += frame_duration\n\n                for packet in out_stream.encode(frame):\n                    yield bytes(packet)\n\n                # Maintain real-time pacing\n                now = time.time()\n                ahead = audio_time - (now - start_time)\n                if ahead > 0:\n                    time.sleep(ahead)\n\n        finally:\n            logger.info(f'Channel {self.channel.id}: Stream closed')\n            self.channel.client_disconnected()\n            output.close()\n    \n    def _apply_crossfade(self, old_chunk: np.ndarray, new_chunk: np.ndarray, position: int) -> np.ndarray:\n        \"\"\"Apply crossfade mixing between two chunks.\"\"\"\n        chunk_size = old_chunk.shape[1]\n        \n        # Get fade positions\n        fade_start = position\n        fade_end = min(fade_start + chunk_size, THEME_CROSSFADE_SAMPLES)\n        fade_len = fade_end - fade_start\n        \n        if fade_len <= 0 or fade_start >= THEME_CROSSFADE_SAMPLES:\n            # Crossfade complete, just return new\n            return new_chunk\n        \n        # Convert to float for mixing\n        old_f = old_chunk.astype(np.float32).flatten()\n        new_f = new_chunk.astype(np.float32).flatten()\n        \n        # Get fade curves for this chunk\n        if fade_len < chunk_size:\n            # Partial fade at end\n            fade_out = np.concatenate([\n                self._fade_out[fade_start:fade_end],\n                np.zeros(chunk_size - fade_len, dtype=np.float32)\n            ])\n            fade_in = np.concatenate([\n                self._fade_in[fade_start:fade_end],\n                np.ones(chunk_size - fade_len, dtype=np.float32)\n            ])\n        else:\n            fade_out = self._fade_out[fade_start:fade_start + chunk_size]\n            fade_in = self._fade_in[fade_start:fade_start + chunk_size]\n        \n        # Mix with crossfade\n        mixed = old_f * fade_out + new_f * fade_in\n        \n        # Convert back to int16\n        mixed = np.clip(mixed, -32768, 32767).astype(np.int16)\n        \n        return mixed.reshape(1, -1)\n\n\nclass ChannelManager:\n    \"\"\"\n    Manages a pool of audio channels.\n    \n    Channels are created at startup based on configuration.\n    Sessions are assigned to channels for playback.\n    \"\"\"\n    \n    def __init__(self, max_channels: int = 6):\n        self.max_channels = max_channels\n        self.channels: dict[int, Channel] = {}\n        \n        # Create channel pool\n        for i in range(1, max_channels + 1):\n            self.channels[i] = Channel(id=i)\n        \n        logger.info(f\"ChannelManager: Created {max_channels} channels\")\n    \n    def get_channel(self, channel_id: int) -> Optional[Channel]:\n        \"\"\"Get a channel by ID.\"\"\"\n        return self.channels.get(channel_id)\n    \n    def get_available_channel(self) -> Optional[Channel]:\n        \"\"\"\n        Get an available (idle) channel.\n        \n        Returns the lowest-numbered idle channel, or None if all are in use.\n        \"\"\"\n        for i in range(1, self.max_channels + 1):\n            channel = self.channels[i]\n            if channel.state == ChannelState.IDLE:\n                return channel\n        return None\n    \n    def get_channel_for_theme(self, theme_id: str) -> Optional[Channel]:\n        \"\"\"\n        Find a channel already playing the given theme.\n        \n        Useful for sharing channels when multiple sessions use the same theme.\n        \"\"\"\n        for channel in self.channels.values():\n            if channel.current_theme_id == theme_id:\n                return channel\n        return None\n    \n    def list_channels(self) -> list[dict]:\n        \"\"\"Get status of all channels for API.\"\"\"\n        return [ch.to_dict() for ch in self.channels.values()]\n    \n    def get_active_count(self) -> int:\n        \"\"\"Count channels with connected clients.\"\"\"\n        return sum(1 for ch in self.channels.values() if ch.is_active)