"""\nSession Manager\n\nHandles CRUD operations for playback sessions, including:\n- Creating sessions with auto-naming\n- Updating session configuration\n- Play/pause/stop control with channel-based streaming\n- Volume management\n- Seamless theme transitions via channel crossfading\n- Theme cycling integration\n"""\n\nfrom __future__ import annotations\n\nimport uuid\nfrom typing import Optional, TYPE_CHECKING\n\nfrom sonorium.core.state import (\n    Session,\n    SpeakerSelection,\n    SpeakerGroup,\n    CycleConfig,\n    NameSource,\n    StateStore,\n)\nfrom sonorium.obs import logger\n\nif TYPE_CHECKING:\n    from sonorium.ha.registry import HARegistry\n    from sonorium.ha.media_controller import HAMediaController\n    from sonorium.core.channel import ChannelManager, Channel\n    from sonorium.core.cycle_manager import CycleManager\n    from sonorium.theme import ThemeDefinition\n    from fmtr.tools.iterator_tools import IndexList\n\n\nclass SessionManager:\n    \"\"\"\n    Manages playback sessions.\n    \n    Each session represents one theme playing to one set of speakers.\n    Multiple sessions can run simultaneously on different channels.\n    \"\"\"\n    \n    def __init__(\n        self, \n        state_store: StateStore, \n        ha_registry: HARegistry,\n        media_controller: HAMediaController = None,\n        stream_base_url: str = None,\n        channel_manager: ChannelManager = None,\n        cycle_manager: CycleManager = None,\n        themes: IndexList[ThemeDefinition] = None,\n    ):\n        self.state = state_store\n        self.registry = ha_registry\n        self.media_controller = media_controller\n        self.stream_base_url = stream_base_url or \"http://localhost:8080\"\n        self.channel_manager = channel_manager\n        self.cycle_manager = cycle_manager\n        self.themes = themes\n        \n        # Track which session is using which channel: session_id -> channel_id\n        self._session_channels: dict[str, int] = {}\n    \n    def set_media_controller(self, controller: HAMediaController):\n        \"\"\"Set the media controller (for deferred initialization).\"\"\"\n        self.media_controller = controller\n    \n    def set_stream_base_url(self, url: str):\n        \"\"\"Set the stream base URL.\"\"\"\n        self.stream_base_url = url.rstrip(\"/\")\n    \n    def set_cycle_manager(self, cycle_manager: CycleManager):\n        \"\"\"Set the cycle manager (for deferred initialization).\"\"\"\n        self.cycle_manager = cycle_manager\n    \n    def get_theme(self, theme_id: str) -> Optional[ThemeDefinition]:\n        \"\"\"Get a theme by ID.\"\"\"\n        if not self.themes:\n            return None\n        return self.themes.id.get(theme_id)\n    \n    def get_stream_url(self, session: Session) -> str:\n        \"\"\"\n        Get the stream URL for a session.\n        \n        Uses channel-based URL if channel is assigned, otherwise falls back to theme URL.\n        \"\"\"\n        channel_id = self._session_channels.get(session.id)\n        if channel_id:\n            return f\"{self.stream_base_url}/stream/channel{channel_id}\"\n        # Fallback to theme-based URL (legacy)\n        return f\"{self.stream_base_url}/stream/{session.theme_id}\"\n    \n    def _assign_channel(self, session: Session) -> Optional[Channel]:\n        \"\"\"\n        Assign an available channel to a session.\n        \n        Returns the assigned channel, or None if no channels available.\n        \"\"\"\n        if not self.channel_manager:\n            return None\n        \n        # Check if session already has a channel\n        existing_id = self._session_channels.get(session.id)\n        if existing_id:\n            return self.channel_manager.get_channel(existing_id)\n        \n        # Get an available channel\n        channel = self.channel_manager.get_available_channel()\n        if channel:\n            self._session_channels[session.id] = channel.id\n            logger.info(f\"  Assigned channel {channel.id} to session {session.id}\")\n        \n        return channel\n    \n    def _release_channel(self, session_id: str):\n        \"\"\"Release a channel from a session.\"\"\"\n        channel_id = self._session_channels.pop(session_id, None)\n        if channel_id and self.channel_manager:\n            channel = self.channel_manager.get_channel(channel_id)\n            if channel:\n                channel.stop()\n                logger.info(f\"  Released channel {channel_id} from session {session_id}\")\n    \n    def get_session_channel(self, session_id: str) -> Optional[int]:\n        \"\"\"Get the channel ID assigned to a session.\"\"\"\n        return self._session_channels.get(session_id)\n    \n    # --- Auto-naming ---\n    \n    def generate_session_name(\n        self,\n        selection: SpeakerSelection = None,\n        group: SpeakerGroup = None,\n    ) -> tuple[str, NameSource]:\n        \"\"\"\n        Generate a session name based on speaker selection.\n        \n        Priority:\n        1. If using a saved group -> group name\n        2. If single floor selected -> floor name\n        3. If single area selected -> area name\n        4. If multiple areas -> \"Area1 & Area2\" or \"Area1 + N more\"\n        5. If single speaker -> speaker name\n        6. Fallback -> \"N Speakers\"\n        \n        Returns:\n            Tuple of (name, source)\n        \"\"\"\n        # If using a saved group, use its name\n        if group:\n            return (group.name, NameSource.AUTO_GROUP)\n        \n        if not selection:\n            return (\"New Session\", NameSource.CUSTOM)\n        \n        # Single floor selected (with possible exclusions)\n        if (len(selection.include_floors) == 1 and \n            not selection.include_areas and \n            not selection.include_speakers):\n            floor_name = self.registry.get_floor_name(selection.include_floors[0])\n            return (floor_name, NameSource.AUTO_FLOOR)\n        \n        # Single area selected\n        if (len(selection.include_areas) == 1 and \n            not selection.include_floors and \n            not selection.include_speakers):\n            area_name = self.registry.get_area_name(selection.include_areas[0])\n            return (area_name, NameSource.AUTO_AREA)\n        \n        # Multiple areas (no floors)\n        if selection.include_areas and not selection.include_floors:\n            area_names = [self.registry.get_area_name(a) for a in selection.include_areas]\n            if len(area_names) == 2:\n                return (f\"{area_names[0]} & {area_names[1]}\", NameSource.AUTO_AREA)\n            elif len(area_names) > 2:\n                return (f\"{area_names[0]} + {len(area_names) - 1} more\", NameSource.AUTO_AREA)\n        \n        # Single speaker selected\n        if (len(selection.include_speakers) == 1 and \n            not selection.include_floors and \n            not selection.include_areas):\n            speaker_name = self.registry.get_speaker_name(selection.include_speakers[0])\n            return (speaker_name, NameSource.AUTO_AREA)\n        \n        # Fallback: count resolved speakers\n        resolved = self.registry.resolve_selection(\n            include_floors=selection.include_floors,\n            include_areas=selection.include_areas,\n            include_speakers=selection.include_speakers,\n            exclude_areas=selection.exclude_areas,\n            exclude_speakers=selection.exclude_speakers,\n        )\n        return (f\"{len(resolved)} Speakers\", NameSource.AUTO_AREA)\n    \n    # --- CRUD Operations ---\n    \n    @logger.instrument(\"Creating new session...\")\n    def create(\n        self,\n        theme_id: str = None,\n        speaker_group_id: str = None,\n        adhoc_selection: SpeakerSelection = None,\n        custom_name: str = None,\n        volume: int = None,\n        cycle_config: CycleConfig = None,\n    ) -> Session:\n        \"\"\"\n        Create a new session.\n        \n        Args:\n            theme_id: Theme to play (optional, can set later)\n            speaker_group_id: Saved speaker group to use\n            adhoc_selection: Ad-hoc speaker selection (if not using group)\n            custom_name: Custom name (overrides auto-naming)\n            volume: Initial volume (uses default if not specified)\n            cycle_config: Theme cycling configuration (optional)\n        \n        Returns:\n            Created session\n        \n        Raises:\n            ValueError: If max sessions exceeded\n        \"\"\"\n        # Check limits\n        max_sessions = self.state.settings.max_sessions\n        if len(self.state.sessions) >= max_sessions:\n            raise ValueError(f\"Maximum of {max_sessions} sessions allowed\")\n        \n        # Generate ID\n        session_id = str(uuid.uuid4())[:8]\n        \n        # Determine name\n        if custom_name:\n            name = custom_name\n            name_source = NameSource.CUSTOM\n        else:\n            group = None\n            if speaker_group_id:\n                group = self.state.speaker_groups.get(speaker_group_id)\n            name, name_source = self.generate_session_name(adhoc_selection, group)\n        \n        # Use default volume if not specified\n        if volume is None:\n            volume = self.state.settings.default_volume\n        \n        # Use provided cycle_config or create default\n        if cycle_config is None:\n            cycle_config = CycleConfig(\n                enabled=False,\n                interval_minutes=self.state.settings.default_cycle_interval,\n                randomize=self.state.settings.default_cycle_randomize,\n            )\n        \n        # Create session\n        session = Session(\n            id=session_id,\n            name=name,\n            name_source=name_source,\n            theme_id=theme_id,\n            speaker_group_id=speaker_group_id,\n            adhoc_selection=adhoc_selection,\n            volume=volume,\n            is_playing=False,\n            cycle_config=cycle_config,\n        )\n        \n        # Store and save\n        self.state.sessions[session_id] = session\n        self.state.save()\n        \n        logger.info(f\"  Created session '{session.name}' ({session_id})\")\n        return session\n    \n    def get(self, session_id: str) -> Optional[Session]:\n        \"\"\"Get a session by ID.\"\"\"\n        return self.state.sessions.get(session_id)\n    \n    def list(self) -> list[Session]:\n        \"\"\"List all sessions, sorted by creation time.\"\"\"\n        sessions = list(self.state.sessions.values())\n        sessions.sort(key=lambda s: s.created_at)\n        return sessions\n    \n    @logger.instrument(\"Updating session {session_id}...\")\n    def update(\n        self,\n        session_id: str,\n        theme_id: str = None,\n        speaker_group_id: str = None,\n        adhoc_selection: SpeakerSelection = None,\n        custom_name: str = None,\n        volume: int = None,\n        cycle_config: CycleConfig = None,\n    ) -> Optional[Session]:\n        \"\"\"\n        Update an existing session.\n        \n        Only provided fields are updated.\n        If theme changes on a playing session, triggers seamless crossfade.\n        \n        Returns:\n            Updated session, or None if not found\n        \"\"\"\n        session = self.state.sessions.get(session_id)\n        if not session:\n            logger.warning(f\"  Session {session_id} not found\")\n            return None\n        \n        # Track if theme is changing\n        theme_changed = theme_id is not None and theme_id != session.theme_id\n        \n        # Update fields if provided\n        if theme_id is not None:\n            session.theme_id = theme_id\n        \n        if speaker_group_id is not None:\n            session.speaker_group_id = speaker_group_id\n            session.adhoc_selection = None  # Clear ad-hoc if using group\n        \n        if adhoc_selection is not None:\n            session.adhoc_selection = adhoc_selection\n            session.speaker_group_id = None  # Clear group if using ad-hoc\n        \n        if custom_name is not None:\n            session.name = custom_name\n            session.name_source = NameSource.CUSTOM\n        \n        if volume is not None:\n            session.volume = max(0, min(100, volume))\n        \n        if cycle_config is not None:\n            session.cycle_config = cycle_config\n        \n        # Re-generate auto-name if needed\n        if custom_name is None and session.name_source != NameSource.CUSTOM:\n            group = None\n            if session.speaker_group_id:\n                group = self.state.speaker_groups.get(session.speaker_group_id)\n            session.name, session.name_source = self.generate_session_name(\n                session.adhoc_selection, group\n            )\n        \n        self.state.save()\n        \n        # If session is playing and theme changed, trigger crossfade\n        if session.is_playing and theme_changed and session.theme_id:\n            self._trigger_theme_crossfade(session)\n            \n            # Reset cycle timer since theme was manually changed\n            if self.cycle_manager:\n                self.cycle_manager.reset_cycle(session_id)\n        \n        logger.info(f\"  Updated session '{session.name}'\")\n        return session\n    \n    def update_cycle_config(\n        self,\n        session_id: str,\n        enabled: bool = None,\n        interval_minutes: int = None,\n        randomize: bool = None,\n        theme_ids: list[str] = None,\n    ) -> Optional[Session]:\n        \"\"\"\n        Update just the cycle configuration for a session.\n        \n        Convenience method for updating cycle settings without\n        affecting other session properties.\n        \"\"\"\n        session = self.state.sessions.get(session_id)\n        if not session:\n            return None\n        \n        if enabled is not None:\n            session.cycle_config.enabled = enabled\n        \n        if interval_minutes is not None:\n            session.cycle_config.interval_minutes = max(1, interval_minutes)\n        \n        if randomize is not None:\n            session.cycle_config.randomize = randomize\n        \n        if theme_ids is not None:\n            session.cycle_config.theme_ids = theme_ids\n        \n        self.state.save()\n        \n        # Reset cycle timer if cycling was just enabled\n        if enabled and self.cycle_manager:\n            self.cycle_manager.reset_cycle(session_id)\n        \n        logger.info(f\"  Updated cycle config for '{session.name}': enabled={session.cycle_config.enabled}, interval={session.cycle_config.interval_minutes}m\")\n        return session\n    \n    def _trigger_theme_crossfade(self, session: Session):\n        \"\"\"Trigger a theme crossfade on the session's channel.\"\"\"\n        channel_id = self._session_channels.get(session.id)\n        if not channel_id or not self.channel_manager:\n            return\n        \n        channel = self.channel_manager.get_channel(channel_id)\n        if not channel:\n            return\n        \n        theme = self.get_theme(session.theme_id)\n        if not theme:\n            return\n        \n        logger.info(f\"  Triggering crossfade to '{theme.name}' on channel {channel_id}\")\n        channel.set_theme(theme)\n    \n    @logger.instrument(\"Deleting session {session_id}...\")\n    def delete(self, session_id: str) -> bool:\n        \"\"\"\n        Delete a session.\n        \n        Returns:\n            True if deleted, False if not found\n        \"\"\"\n        if session_id not in self.state.sessions:\n            logger.warning(f\"  Session {session_id} not found\")\n            return False\n        \n        # Release channel if assigned\n        self._release_channel(session_id)\n        \n        session = self.state.sessions.pop(session_id)\n        self.state.save()\n        \n        logger.info(f\"  Deleted session '{session.name}'\")\n        return True\n    \n    # --- Speaker Resolution ---\n    \n    def get_resolved_speakers(self, session: Session) -> list[str]:\n        \"\"\"\n        Get the list of speaker entity_ids for a session.\n        \n        Resolves speaker group or ad-hoc selection to final list.\n        \"\"\"\n        if session.speaker_group_id:\n            group = self.state.speaker_groups.get(session.speaker_group_id)\n            if group:\n                return self.registry.resolve_selection(\n                    include_floors=group.include_floors,\n                    include_areas=group.include_areas,\n                    include_speakers=group.include_speakers,\n                    exclude_areas=group.exclude_areas,\n                    exclude_speakers=group.exclude_speakers,\n                )\n        \n        if session.adhoc_selection:\n            sel = session.adhoc_selection\n            return self.registry.resolve_selection(\n                include_floors=sel.include_floors,\n                include_areas=sel.include_areas,\n                include_speakers=sel.include_speakers,\n                exclude_areas=sel.exclude_areas,\n                exclude_speakers=sel.exclude_speakers,\n            )\n        \n        return []\n    \n    def get_speaker_summary(self, session: Session) -> str:\n        \"\"\"\n        Get human-readable speaker summary for a session.\n        \n        Examples:\n        - \"3 speakers\"\n        - \"Bedroom Level (2 excluded)\"\n        - \"Office Echo\"\n        \"\"\"\n        speakers = self.get_resolved_speakers(session)\n        \n        if not speakers:\n            return \"No speakers\"\n        \n        if len(speakers) == 1:\n            return self.registry.get_speaker_name(speakers[0])\n        \n        # Check for exclusions\n        excluded_count = 0\n        if session.speaker_group_id:\n            group = self.state.speaker_groups.get(session.speaker_group_id)\n            if group:\n                excluded_count = len(group.exclude_areas) + len(group.exclude_speakers)\n        elif session.adhoc_selection:\n            sel = session.adhoc_selection\n            excluded_count = len(sel.exclude_areas) + len(sel.exclude_speakers)\n        \n        if excluded_count > 0:\n            return f\"{len(speakers)} speakers ({excluded_count} excluded)\"\n        \n        return f\"{len(speakers)} speakers\"\n    \n    # --- Playback Control ---\n    \n    @logger.instrument(\"Playing session {session_id}...\")\n    async def play(self, session_id: str) -> bool:\n        \"\"\"\n        Start playback for a session.\n        \n        Assigns a channel, sets the theme, and sends stream URL to speakers.\n        Also initializes the cycle timer if cycling is enabled.\n        \n        Returns:\n            True if started successfully, False otherwise\n        \"\"\"\n        session = self.state.sessions.get(session_id)\n        if not session:\n            logger.warning(f\"  Session {session_id} not found\")\n            return False\n        \n        if not session.theme_id:\n            logger.warning(f\"  Session has no theme selected\")\n            return False\n        \n        speakers = self.get_resolved_speakers(session)\n        if not speakers:\n            logger.warning(f\"  Session has no speakers\")\n            return False\n        \n        if not self.media_controller:\n            logger.warning(f\"  No media controller available\")\n            return False\n        \n        # Assign channel and set theme\n        channel = self._assign_channel(session)\n        if channel:\n            theme = self.get_theme(session.theme_id)\n            if theme:\n                channel.set_theme(theme)\n                logger.info(f\"  Channel {channel.id}: theme '{theme.name}'\")\n        \n        # Build stream URL (channel-based if available)\n        stream_url = self.get_stream_url(session)\n        logger.info(f\"  Stream URL: {stream_url}\")\n        \n        # Mark as playing immediately (optimistic update)\n        session.is_playing = True\n        session.mark_played()\n        self.state.save()\n        \n        # Initialize cycle timer if enabled\n        if session.cycle_config.enabled and self.cycle_manager:\n            self.cycle_manager.reset_cycle(session_id)\n            logger.info(f\"  Cycle enabled: every {session.cycle_config.interval_minutes}m\")\n        \n        # Play on all speakers (fire-and-forget)\n        import asyncio\n        asyncio.create_task(self._play_on_speakers(session, speakers, stream_url))\n        \n        return True\n    \n    async def _play_on_speakers(self, session: Session, speakers: list[str], stream_url: str):\n        \"\"\"Background task to play media on speakers.\"\"\"\n        try:\n            results = await self.media_controller.play_media_multi(speakers, stream_url)\n            \n            # Set volume on all speakers\n            volume_level = session.volume / 100.0\n            await self.media_controller.set_volume_multi(speakers, volume_level)\n            \n            success_count = sum(1 for v in results.values() if v)\n            logger.info(f\"  Started playback on {success_count}/{len(speakers)} speakers\")\n            \n        except Exception as e:\n            logger.error(f\"  Error starting playback: {e}\")\n    \n    @logger.instrument(\"Pausing session {session_id}...\")\n    async def pause(self, session_id: str) -> bool:\n        \"\"\"\n        Pause playback for a session.\n        \n        Returns:\n            True if paused, False if session not found\n        \"\"\"\n        session = self.state.sessions.get(session_id)\n        if not session:\n            logger.warning(f\"  Session {session_id} not found\")\n            return False\n        \n        speakers = self.get_resolved_speakers(session)\n        \n        if self.media_controller and speakers:\n            await self.media_controller.pause_multi(speakers)\n        \n        session.is_playing = False\n        self.state.save()\n        \n        logger.info(f\"  Paused session '{session.name}'\")\n        return True\n    \n    @logger.instrument(\"Stopping session {session_id}...\")\n    async def stop(self, session_id: str) -> bool:\n        \"\"\"\n        Stop playback for a session.\n        \n        Releases the channel and stops speakers.\n        \n        Returns:\n            True if stopped, False if session not found\n        \"\"\"\n        session = self.state.sessions.get(session_id)\n        if not session:\n            logger.warning(f\"  Session {session_id} not found\")\n            return False\n        \n        speakers = self.get_resolved_speakers(session)\n        \n        if self.media_controller and speakers:\n            await self.media_controller.stop_multi(speakers)\n        \n        # Release channel\n        self._release_channel(session_id)\n        \n        session.is_playing = False\n        self.state.save()\n        \n        logger.info(f\"  Stopped session '{session.name}'\")\n        return True\n    \n    @logger.instrument(\"Setting volume for session {session_id} to {volume}...\")\n    async def set_volume(self, session_id: str, volume: int) -> bool:\n        \"\"\"\n        Set volume for a session.\n        \n        Args:\n            session_id: Session to update\n            volume: Volume level 0-100\n        \n        Returns:\n            True if set, False if session not found\n        \"\"\"\n        session = self.state.sessions.get(session_id)\n        if not session:\n            logger.warning(f\"  Session {session_id} not found\")\n            return False\n        \n        session.volume = max(0, min(100, volume))\n        self.state.save()\n        \n        # If playing, update volume on speakers\n        if session.is_playing and self.media_controller:\n            speakers = self.get_resolved_speakers(session)\n            if speakers:\n                volume_level = session.volume / 100.0\n                await self.media_controller.set_volume_multi(speakers, volume_level)\n        \n        logger.info(f\"  Set volume to {session.volume}%\")\n        return True\n    \n    async def stop_all(self) -> int:\n        \"\"\"\n        Stop all playing sessions.\n        \n        Returns:\n            Number of sessions stopped\n        \"\"\"\n        count = 0\n        for session in self.state.sessions.values():\n            if session.is_playing:\n                await self.stop(session.id)\n                count += 1\n        return count