"""\nSonorium State Management\n\nHandles persistence of sessions, speaker groups, and settings to JSON.\nState is stored in /config/sonorium/state.json to survive addon updates.\n"""\n\nfrom __future__ import annotations\n\nimport json\nfrom dataclasses import dataclass, field, asdict\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Optional\nfrom enum import Enum\n\nfrom sonorium.obs import logger\n\n\n# Default paths\nDEFAULT_STATE_DIR = Path(\"/config/sonorium\")\nDEFAULT_STATE_FILE = DEFAULT_STATE_DIR / \"state.json\"\n\n\nclass NameSource(str, Enum):\n    \"\"\"How a session name was determined.\"\"\"\n    AUTO_FLOOR = \"auto_floor\"      # Named after selected floor\n    AUTO_AREA = \"auto_area\"        # Named after selected area(s)\n    AUTO_GROUP = \"auto_group\"      # Named after speaker group\n    CUSTOM = \"custom\"              # User-defined name\n\n\n@dataclass\nclass CycleConfig:\n    \"\"\"\n    Theme cycling configuration for a session.\n    \n    When enabled, the session will automatically rotate through themes\n    at the specified interval.\n    \"\"\"\n    \n    enabled: bool = False\n    interval_minutes: int = 60  # How often to change themes\n    randomize: bool = False     # True = random order, False = sequential\n    \n    # Optional: specific themes to cycle through (empty = all themes)\n    theme_ids: list[str] = field(default_factory=list)\n    \n    # Runtime state (not persisted)\n    current_index: int = 0      # Current position in theme list\n    last_change: Optional[str] = None  # ISO timestamp of last theme change\n    \n    def to_dict(self) -> dict:\n        return {\n            \"enabled\": self.enabled,\n            \"interval_minutes\": self.interval_minutes,\n            \"randomize\": self.randomize,\n            \"theme_ids\": self.theme_ids,\n            # Don't persist runtime state\n        }\n    \n    @classmethod\n    def from_dict(cls, data: dict) -> CycleConfig:\n        if data is None:\n            return cls()\n        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})\n\n\n@dataclass\nclass SonoriumSettings:\n    \"\"\"Global settings for Sonorium.\"\"\"\n    \n    default_volume: int = 60\n    crossfade_duration: float = 3.0\n    max_sessions: int = 10\n    max_groups: int = 20\n    entity_prefix: str = \"sonorium\"\n    show_in_sidebar: bool = True\n    auto_create_quick_play: bool = True\n    \n    # Default cycling settings (applied to new sessions)\n    default_cycle_interval: int = 60  # minutes\n    default_cycle_randomize: bool = False\n    \n    def to_dict(self) -> dict:\n        return asdict(self)\n    \n    @classmethod\n    def from_dict(cls, data: dict) -> SonoriumSettings:\n        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})\n\n\n@dataclass\nclass SpeakerSelection:\n    \"\"\"\n    Inline speaker selection (not saved as a group).\n    Used for ad-hoc selections in sessions.\n    \"\"\"\n    \n    # Additive selections (union of all)\n    include_floors: list[str] = field(default_factory=list)\n    include_areas: list[str] = field(default_factory=list)\n    include_speakers: list[str] = field(default_factory=list)\n    \n    # Subtractive exclusions\n    exclude_areas: list[str] = field(default_factory=list)\n    exclude_speakers: list[str] = field(default_factory=list)\n    \n    def is_empty(self) -> bool:\n        \"\"\"Check if no speakers are selected.\"\"\"\n        return (\n            not self.include_floors and \n            not self.include_areas and \n            not self.include_speakers\n        )\n    \n    def to_dict(self) -> dict:\n        return asdict(self)\n    \n    @classmethod\n    def from_dict(cls, data: dict) -> SpeakerSelection:\n        if data is None:\n            return None\n        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})\n\n\n@dataclass\nclass SpeakerGroup:\n    \"\"\"\n    A saved speaker selection configuration.\n    Can be reused across multiple sessions.\n    \"\"\"\n    \n    id: str\n    name: str\n    icon: str = \"mdi:speaker-group\"\n    \n    # Additive selections (union of all)\n    include_floors: list[str] = field(default_factory=list)\n    include_areas: list[str] = field(default_factory=list)\n    include_speakers: list[str] = field(default_factory=list)\n    \n    # Subtractive exclusions\n    exclude_areas: list[str] = field(default_factory=list)\n    exclude_speakers: list[str] = field(default_factory=list)\n    \n    created_at: str = \"\"  # ISO format\n    updated_at: str = \"\"  # ISO format\n    \n    def __post_init__(self):\n        now = datetime.utcnow().isoformat()\n        if not self.created_at:\n            self.created_at = now\n        if not self.updated_at:\n            self.updated_at = now\n    \n    def touch(self):\n        \"\"\"Update the updated_at timestamp.\"\"\"\n        self.updated_at = datetime.utcnow().isoformat()\n    \n    def to_selection(self) -> SpeakerSelection:\n        \"\"\"Convert to a SpeakerSelection for resolution.\"\"\"\n        return SpeakerSelection(\n            include_floors=self.include_floors,\n            include_areas=self.include_areas,\n            include_speakers=self.include_speakers,\n            exclude_areas=self.exclude_areas,\n            exclude_speakers=self.exclude_speakers,\n        )\n    \n    def to_dict(self) -> dict:\n        return asdict(self)\n    \n    @classmethod\n    def from_dict(cls, data: dict) -> SpeakerGroup:\n        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})\n\n\n@dataclass\nclass Session:\n    \"\"\"\n    An active or configured playback session.\n    Each session plays one theme to one speaker group/selection.\n    \"\"\"\n    \n    id: str\n    name: str\n    name_source: NameSource = NameSource.AUTO_AREA\n    \n    # What to play\n    theme_id: Optional[str] = None\n    \n    # Where to play - either a saved group OR ad-hoc selection\n    speaker_group_id: Optional[str] = None\n    adhoc_selection: Optional[SpeakerSelection] = None\n    \n    # Playback state\n    volume: int = 60\n    is_playing: bool = False\n    \n    # Theme cycling configuration\n    cycle_config: CycleConfig = field(default_factory=CycleConfig)\n    \n    # Metadata\n    created_at: str = \"\"  # ISO format\n    last_played_at: Optional[str] = None  # ISO format\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.utcnow().isoformat()\n        \n        # Convert name_source from string if needed\n        if isinstance(self.name_source, str):\n            self.name_source = NameSource(self.name_source)\n        \n        # Convert adhoc_selection from dict if needed\n        if isinstance(self.adhoc_selection, dict):\n            self.adhoc_selection = SpeakerSelection.from_dict(self.adhoc_selection)\n        \n        # Convert cycle_config from dict if needed\n        if isinstance(self.cycle_config, dict):\n            self.cycle_config = CycleConfig.from_dict(self.cycle_config)\n    \n    def get_entity_slug(self) -> str:\n        \"\"\"Generate HA entity slug from name.\"\"\"\n        # \"Bedroom Level\" -> \"bedroom_level\"\n        # \"Night Mode Speakers\" -> \"night_mode_speakers\"\n        slug = self.name.lower()\n        slug = slug.replace(\" \", \"_\")\n        slug = slug.replace(\"-\", \"_\")\n        # Remove non-alphanumeric except underscore\n        slug = \"\".join(c for c in slug if c.isalnum() or c == \"_\")\n        # Collapse multiple underscores\n        while \"__\" in slug:\n            slug = slug.replace(\"__\", \"_\")\n        return slug.strip(\"_\")\n    \n    def mark_played(self):\n        \"\"\"Update last_played_at timestamp.\"\"\"\n        self.last_played_at = datetime.utcnow().isoformat()\n    \n    def to_dict(self) -> dict:\n        data = asdict(self)\n        data['name_source'] = self.name_source.value\n        # Handle cycle_config separately to avoid nested asdict issues\n        data['cycle_config'] = self.cycle_config.to_dict() if self.cycle_config else None\n        return data\n    \n    @classmethod\n    def from_dict(cls, data: dict) -> Session:\n        # Handle nested objects\n        if 'adhoc_selection' in data and data['adhoc_selection'] is not None:\n            if isinstance(data['adhoc_selection'], dict):\n                data['adhoc_selection'] = SpeakerSelection.from_dict(data['adhoc_selection'])\n        if 'cycle_config' in data and data['cycle_config'] is not None:\n            if isinstance(data['cycle_config'], dict):\n                data['cycle_config'] = CycleConfig.from_dict(data['cycle_config'])\n        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})\n\n\n@dataclass\nclass SonoriumState:\n    \"\"\"\n    Complete persisted state for Sonorium.\n    Saved to /config/sonorium/state.json\n    \"\"\"\n    \n    settings: SonoriumSettings = field(default_factory=SonoriumSettings)\n    speaker_groups: dict[str, SpeakerGroup] = field(default_factory=dict)\n    sessions: dict[str, Session] = field(default_factory=dict)\n    \n    # Version for future migrations\n    version: int = 1\n    \n    def to_dict(self) -> dict:\n        return {\n            \"version\": self.version,\n            \"settings\": self.settings.to_dict(),\n            \"speaker_groups\": {k: v.to_dict() for k, v in self.speaker_groups.items()},\n            \"sessions\": {k: v.to_dict() for k, v in self.sessions.items()},\n        }\n    \n    @classmethod\n    def from_dict(cls, data: dict) -> SonoriumState:\n        state = cls()\n        state.version = data.get(\"version\", 1)\n        \n        if \"settings\" in data:\n            state.settings = SonoriumSettings.from_dict(data[\"settings\"])\n        \n        if \"speaker_groups\" in data:\n            for k, v in data[\"speaker_groups\"].items():\n                state.speaker_groups[k] = SpeakerGroup.from_dict(v)\n        \n        if \"sessions\" in data:\n            for k, v in data[\"sessions\"].items():\n                state.sessions[k] = Session.from_dict(v)\n        \n        return state\n\n\nclass StateStore:\n    \"\"\"\n    Manages loading and saving of Sonorium state.\n    \"\"\"\n    \n    def __init__(self, state_file: Path = DEFAULT_STATE_FILE):\n        self.state_file = state_file\n        self.state: SonoriumState = SonoriumState()\n    \n    @logger.instrument(\"Loading state from {self.state_file}...\")\n    def load(self) -> SonoriumState:\n        \"\"\"Load state from disk, or create default if not exists.\"\"\"\n        if not self.state_file.exists():\n            logger.info(\"  No existing state file, using defaults\")\n            self.state = SonoriumState()\n            return self.state\n        \n        try:\n            data = json.loads(self.state_file.read_text())\n            self.state = SonoriumState.from_dict(data)\n            logger.info(f\"  Loaded {len(self.state.sessions)} sessions, {len(self.state.speaker_groups)} groups\")\n        except Exception as e:\n            logger.error(f\"  Failed to load state: {e}\")\n            self.state = SonoriumState()\n        \n        return self.state\n    \n    @logger.instrument(\"Saving state to {self.state_file}...\")\n    def save(self):\n        \"\"\"Persist state to disk.\"\"\"\n        try:\n            # Ensure directory exists\n            self.state_file.parent.mkdir(parents=True, exist_ok=True)\n            \n            # Write with pretty formatting\n            data = self.state.to_dict()\n            self.state_file.write_text(json.dumps(data, indent=2))\n            \n            logger.info(f\"  Saved {len(self.state.sessions)} sessions, {len(self.state.speaker_groups)} groups\")\n        except Exception as e:\n            logger.error(f\"  Failed to save state: {e}\")\n            raise\n    \n    # Convenience accessors\n    @property\n    def settings(self) -> SonoriumSettings:\n        return self.state.settings\n    \n    @property\n    def sessions(self) -> dict[str, Session]:\n        return self.state.sessions\n    \n    @property\n    def speaker_groups(self) -> dict[str, SpeakerGroup]:\n        return self.state.speaker_groups